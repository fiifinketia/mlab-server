"""
Do not edit this file
This is the file that will be used to test your model
"""
import asyncio
import os
import argparse
import json
import requests

def parse_list(value):
    # Check if the value is a list
    if value.startswith('[') and value.endswith(']'):
        # Remove brackets
        value = value[1:-1]
        result = []
        nested_level = 0
        start = 0

        # Iterate through characters in the value
        for i, char in enumerate(value):
            if char == '[':
                nested_level += 1
            elif char == ']':
                nested_level -= 1
            elif char == ',' and nested_level == 0:
                # Split at the top level commas
                result.append(parse_list(value[start:i]))
                start = i + 1

        # Add the last part after the last comma (or whole value if no commas)
        result.append(parse_list(value[start:]))

        return result
    else:
        # If it's not a list, return the value itself
        return convert_type(value)

def convert_type(value):
    # Convert string to appropriate type
    try:
        if '.' in value:
            return float(value)
        else:
            return int(value)
    except ValueError:
        return str(value)

def fetch_parameters(config_path):
    parameters = {}
    with open(config_path, 'r') as file:
        for line in file:
            parts = line.strip().split()
            if len(parts) >= 4 and parts[0] == 'PARAM':
                param_name = parts[1]
                param_type = parts[2]
                param_value = ' '.join(parts[3:])

                if param_type.startswith('list'):
                    # If it's a list type, parse the value accordingly
                    parameters[param_name] = parse_list(param_value)
                else:
                    if param_type == 'int':
                        parameters[param_name] = int(param_value)
                    elif param_type == 'float':
                        parameters[param_name] = float(param_value)
                    elif param_type == 'bool':
                        parameters[param_name] = param_value.lower() == 'true'
                    else:
                        parameters[param_name] = str(param_value)

    return parameters

class TestResults:
    """Results of testing."""
    def __init__(self, metrics: dict[str, float], files: [], predictions: []):
        self.metrics = metrics
        self.files = files
        self.predictions = predictions

if __name__ == "__main__":
  # Run the model, pass the file location, the file type and the dataset name
  # Where inputs would be from command line
    print("Running model")
    parser=argparse.ArgumentParser(
        description="test a model",
        prog="maldec-test",
    )

    parser.add_argument(
        "--config",
        type=str,
        help="Path to config file",
        required=False,
    )

    parser.add_argument(
        "--result_id",
        type=str,
        help="Result ID",
    )

    parser.add_argument(
        "--trained_model",
        type=str,
        help="Trained model path",
    )

    parser.add_argument(
        "--api_url",
        type=str,
        help="API URL",
    )

    args=parser.parse_args()

    CONFIG_PATH = args.config
    result_id = args.result_id
    trained_model = args.trained_model
    api_url = args.api_url
    if CONFIG_PATH is None:
        CONFIG_PATH = "config.txt" # type: ignore
    parameters = fetch_parameters(config_path=CONFIG_PATH)
    DATASET_PATH = str(parameters["dataset_url"]).strip() # type: ignore

    test_error = False

    # Get API URL from .env file
    try:

        # check if trained model exists
        async def main():
            if not os.path.exists(trained_model):
                raise ValueError("Trained model not found")
            
            test_model = getattr(__import__(f"{parameters['model_path']}.main", fromlist=["test"]), "test")
            print(test_model)
            
            # run test_model asynchronously
            model = await test_model(DATASET_PATH, result_id, trained_model)
            print(os.listdir(f"results/{result_id}"))

            files = {}

            for file in model.files:
                read_file = open(file, 'rb')
                file_name = file.split("/")[-1]
                files[file_name] = (file_name, read_file)


            # Stringify metrics
            metrics = json.dumps(model.metrics)
            data = {
                "result_id": result_id,
                "metrics": metrics,
                "predictions": model.predictions,
            }


            response = requests.post(api_url+f"?error={False}", data=data, files=files,timeout=120)

            if response.status_code == 200:
                print("Successfully uploaded results")
                for file in model.files:
                    os.remove(file)
            else:
                print("Error uploading results")
                # Append error in error.txt file
                # First check if error.txt file exists
                raise requests.HTTPError(f"Error uploading results. Status code: {response.status_code}, error: {response.text}")
            
        
        asyncio.run(main())

    except Exception as e:
        # Append error in error.txt file
        # First check if error.txt file exists
        print("Error: ", e)
        if not os.path.exists(f"{result_id}/error.txt"):
            os.mkdir(result_id)
            with open(f"{result_id}/error.txt", "w", encoding="utf-8") as f:
                f.write(str(e))
        else:
            with open(f"{result_id}/error.txt", "a", encoding="utf-8") as f:
                f.write(str(e))
        error_file = open(f"{result_id}/error.txt", "rb")
        req_files = {
            "error.txt": error_file,
        }
        requests.post(api_url+f"?error={True}", data={"result_id": result_id, "error": str(e)}, files=req_files, timeout=120)
